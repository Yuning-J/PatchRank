import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell, PieChart, Pie, Sector } from 'recharts';
import './VulnerabilityRankingUI.css';

const VulnerabilityRankingUI = ({ apiUrl }) => {
  // State variables
  const [assetRisks, setAssetRisks] = useState([]);
  const [selectedTab, setSelectedTab] = useState('dashboard');
  const [analysisLevel, setAnalysisLevel] = useState('asset');
  const [selectedFile, setSelectedFile] = useState('');
  const [runningAnalysis, setRunningAnalysis] = useState(false);
  const [analysisResults, setAnalysisResults] = useState(null);
  const [patchRankings, setPatchRankings] = useState([]);
  const [systemRisk, setSystemRisk] = useState(0);
  const [componentRisks, setComponentRisks] = useState([]);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Loading state indicators
  const [loadingSteps, setLoadingSteps] = useState([]);
  const [loadingProgress, setLoadingProgress] = useState(0);
  
  // API-specific state
  const [availableConfigs, setAvailableConfigs] = useState({ asset: [], system: [] });
  const [jobId, setJobId] = useState(null);
  const [polling, setPolling] = useState(false);

  const [virtuallyPatchedVulnerabilities, setVirtuallyPatchedVulnerabilities] = useState([]);
  const [originalSystemRisk, setOriginalSystemRisk] = useState(0);
  const [originalComponentRisks, setOriginalComponentRisks] = useState([]);
  const [patchImpact, setPatchImpact] = useState({});
  const [originalAssetRisks, setOriginalAssetRisks] = useState([]);
  const [patchSessionId, setPatchSessionId] = useState(null);
  const [baselineSystemRisk, setBaselineSystemRisk] = useState(0);

  const [vulnerabilityStats, setVulnerabilityStats] = useState({
  cvssDistribution: [],
  exploitDistribution: [],
  locationDistribution: []
});

  const [activeIndex, setActiveIndex] = useState(0);

  // Function to categorize CVSS scores
  const categorizeCVSS = (cvss) => {
    // Ensure cvss is a number
    const score = parseFloat(cvss);
    if (isNaN(score)) return "Unknown";
    if (score >= 9.0) return "Critical";
    if (score >= 7.0) return "High";
    if (score >= 4.0) return "Medium";
    return "Low";
  };

  // Calculate vulnerability statistics with error handling
  // Add this to your useEffect that calculates vulnerability statistics
useEffect(() => {
  try {
    if (Array.isArray(patchRankings) && patchRankings.length > 0) {
      console.log("Calculating vulnerability stats for", patchRankings.length, "vulnerabilities");

      // Process CVSS distribution with defensive coding
      const cvssGroups = {};
      patchRankings.forEach(patch => {
        if (patch && typeof patch.cvss === 'number') {
          const category = categorizeCVSS(patch.cvss);
          cvssGroups[category] = (cvssGroups[category] || 0) + 1;
        }
      });

      const cvssColors = {
        "Critical": "#ef4444",
        "High": "#f97316",
        "Medium": "#f59e0b",
        "Low": "#22c55e",
        "Unknown": "#9ca3af"
      };

      const cvssDistribution = Object.keys(cvssGroups).map(group => ({
        name: group,
        value: cvssGroups[group],
        color: cvssColors[group] || "#3b82f6"
      }));

      // Process exploit status with defensive coding
      const exploitableCount = patchRankings.filter(p => p && p.exploit === true).length;
      const nonExploitableCount = patchRankings.filter(p => p && p.exploit === false).length;

      const exploitDistribution = [
        { name: "Existing Exploit", value: exploitableCount, color: "#dc2626" },
        { name: "No Known Exploit", value: nonExploitableCount, color: "#9ca3af" }
      ].filter(item => item.value > 0); // Remove empty categories

      // Calculate distribution by asset/component
      const distributionByLocation = {};

      patchRankings.forEach(patch => {
        if (patch) {
          // For system level, group by asset name
          if (analysisLevel === 'system' && patch.asset_name) {
            distributionByLocation[patch.asset_name] = (distributionByLocation[patch.asset_name] || 0) + 1;
          }
          // For asset level, group by component id
          else if (patch.component_id) {
            const componentName = `Component ${patch.component_id}`;
            distributionByLocation[componentName] = (distributionByLocation[componentName] || 0) + 1;
          }
        }
      });

      // Convert to array format for the chart
      const locationColors = [
        "#3b82f6", // blue
        "#a855f7", // purple
        "#ec4899", // pink
        "#f43f5e", // rose
        "#f97316", // orange
        "#84cc16", // lime
        "#06b6d4", // cyan
        "#6366f1"  // indigo
      ];

      const locationDistribution = Object.keys(distributionByLocation).map((location, index) => ({
        name: location,
        value: distributionByLocation[location],
        color: locationColors[index % locationColors.length]
      }));

      console.log("Setting vulnerability stats", {
        cvssDistribution,
        exploitDistribution,
        locationDistribution
      });

      setVulnerabilityStats({
        cvssDistribution,
        exploitDistribution,
        locationDistribution
      });
    }
  } catch (error) {
    console.error("Error calculating vulnerability stats:", error);
    // Set default empty values on error to prevent rendering failures
    setVulnerabilityStats({
      cvssDistribution: [],
      exploitDistribution: [],
      locationDistribution: []
    });
  }
}, [patchRankings, analysisLevel]);

  // Pie chart active sector handler
  const onPieEnter = (_, index) => {
    setActiveIndex(index);
  };

  // Pie chart customized active sector
  const renderActiveShape = (props) => {
    const RADIAN = Math.PI / 180;
    const { cx, cy, midAngle, innerRadius, outerRadius, startAngle, endAngle, fill, payload, percent, value } = props;
    const sin = Math.sin(-RADIAN * midAngle);
    const cos = Math.cos(-RADIAN * midAngle);
    const sx = cx + (outerRadius + 10) * cos;
    const sy = cy + (outerRadius + 10) * sin;
    const mx = cx + (outerRadius + 30) * cos;
    const my = cy + (outerRadius + 30) * sin;
    const ex = mx + (cos >= 0 ? 1 : -1) * 22;
    const ey = my;
    const textAnchor = cos >= 0 ? 'start' : 'end';

    return (
      <g>
        <text x={cx} y={cy} dy={8} textAnchor="middle" fill={fill}>
          {payload.name}
        </text>
        <Sector
          cx={cx}
          cy={cy}
          innerRadius={innerRadius}
          outerRadius={outerRadius}
          startAngle={startAngle}
          endAngle={endAngle}
          fill={payload.color || fill}
        />
        <Sector
          cx={cx}
          cy={cy}
          startAngle={startAngle}
          endAngle={endAngle}
          innerRadius={outerRadius + 6}
          outerRadius={outerRadius + 10}
          fill={payload.color || fill}
        />
        <path d={`M${sx},${sy}L${mx},${my}L${ex},${ey}`} stroke={payload.color || fill} fill="none" />
        <circle cx={ex} cy={ey} r={2} fill={payload.color || fill} stroke="none" />
        <text x={ex + (cos >= 0 ? 1 : -1) * 12} y={ey} textAnchor={textAnchor} fill="#333">{`${value} issues`}</text>
        <text x={ex + (cos >= 0 ? 1 : -1) * 12} y={ey} dy={18} textAnchor={textAnchor} fill="#999">
          {`(${(percent * 100).toFixed(1)}%)`}
        </text>
      </g>
    );
  };

// Initialize original values only when analysis results first arrive
useEffect(() => {
  if (analysisResults) {
    setOriginalSystemRisk(systemRisk);
    setBaselineSystemRisk(systemRisk);
    setOriginalComponentRisks([...componentRisks]);
    setOriginalAssetRisks([...assetRisks]);
  }
}, [analysisResults]); // Only depend on analysisResults



// Create session when results are loaded
useEffect(() => {
  if (analysisResults) {
    // Create a new patch session
    const createSession = async () => {
      try {
        // Only try to create a session if we have a file selected
        if (!selectedFile) {
          console.log("No file selected, cannot create patch session");
          return; // Skip creating session if no file is selected
        }

        const response = await axios.post(`${apiUrl}/create_patch_session`, {
          level: analysisLevel,
          file: selectedFile
        });

        if (response.data.success) {
          setPatchSessionId(response.data.session_id);
          console.log("Created patch session:", response.data.session_id);

          // Set original values right after session creation
          setOriginalSystemRisk(systemRisk);
          setOriginalComponentRisks([...componentRisks]);
          setOriginalAssetRisks([...assetRisks]);
        } else {
          // Only set error if we're in the patches tab to avoid showing errors elsewhere
          if (selectedTab === 'patches') {
            setError('Failed to create patch session');
          } else {
            console.error('Failed to create patch session');
          }
        }
      } catch (error) {
        console.error("Failed to create patch session:", error);
        // Only set error if we're currently in the patches tab
        if (selectedTab === 'patches') {
          setError(`Failed to create patch session: ${error.response?.data?.error || error.message}`);
        }
      }
    };

    createSession();
  }
}, [analysisResults, analysisLevel, selectedFile, apiUrl, selectedTab]); // Add selectedTab to dependencies



const handleVirtualPatch = async (vulnerabilityId, componentId, assetName) => {
  setError('');

  if (!patchSessionId) {
    console.error("No active patching session");
    setError('No active patching session');
    return;
  }

  try {
    // Create a unique patch key
    const patchKey = `${vulnerabilityId}_${componentId}${assetName ? `_${assetName}` : ''}`;

    // Determine if this specific vulnerability is currently patched
    const isCurrentlyPatched = virtuallyPatchedVulnerabilities.includes(patchKey);

    const response = await axios.post(`${apiUrl}/simulate_patch_session`, {
      session_id: patchSessionId,
      vulnerability_id: vulnerabilityId,
      component_id: componentId,
      asset_name: assetName || null
    });

    console.log("Patch response:", response.data);

    if (response.data.success) {
      const result = response.data.results;

      // Update virtually patched vulnerabilities
      let updatedPatchedVulnerabilities;
      if (isCurrentlyPatched) {
        // Unpatch this specific vulnerability
        updatedPatchedVulnerabilities = virtuallyPatchedVulnerabilities.filter(key => key !== patchKey);
      } else {
        // Patch this specific vulnerability
        updatedPatchedVulnerabilities = [...virtuallyPatchedVulnerabilities, patchKey];
      }

      setVirtuallyPatchedVulnerabilities(updatedPatchedVulnerabilities);

      // Ensure we're using the most accurate risk calculation
      const newSystemRisk = result.patched_risk || result.risk || systemRisk;
      setSystemRisk(newSystemRisk);

      // Update the risk reduction display
      const absoluteReduction = originalSystemRisk - newSystemRisk;
      const reductionPercentage = originalSystemRisk > 0
          ? ((absoluteReduction / originalSystemRisk) * 100).toFixed(1)
          : "0.0";

      setBaselineSystemRisk(newSystemRisk);
      console.log("Original system risk:", originalSystemRisk);
console.log("API response:", result);
console.log("New system risk from API:", result.patched_risk);
console.log("Calculated new system risk:", newSystemRisk);
console.log("Absolute reduction:", absoluteReduction);
console.log("Reduction percentage:", reductionPercentage);

      // Update asset or component risks with more robust checking
      if (analysisLevel === 'asset' && result.patched_component_risks) {
        setComponentRisks(prev => prev.map((comp, idx) => ({
          ...comp,
          originalRisk: comp.originalRisk || comp.risk,
          risk: result.patched_component_risks[idx]
        })));
      } else if (analysisLevel === 'system' && result.asset_risks) {
        setAssetRisks(prev => {
          // Create a map of existing assets for efficient lookup
          const existingAssetsMap = new Map(prev.map(asset => [asset.name, asset]));

          return result.asset_risks.map(newAsset => ({
            ...existingAssetsMap.get(newAsset.name),
            ...newAsset,
            originalRisk: existingAssetsMap.get(newAsset.name)?.originalRisk || newAsset.original_risk || newAsset.risk
          }));
        });
      }

      setSuccess('Patch simulation completed successfully.');
    } else {
      setError('Failed to simulate patch: Unknown error');
    }
  } catch (error) {
    console.error('Error simulating patch:', error);
    setError(`Failed to simulate patch: ${error.response?.data?.error || error.message}`);
  }
};


const resetVirtualPatching = () => {
  setVirtuallyPatchedVulnerabilities([]);
  setSystemRisk(originalSystemRisk);
  setBaselineSystemRisk(originalSystemRisk);

  if (analysisLevel === 'asset') {
    setComponentRisks(originalComponentRisks);
  } else {
    setAssetRisks(originalAssetRisks);
  }

  setPatchImpact({});
};

// Simplified virtual patch trigger
const simulateVirtualPatch = (vulnerabilityId, componentId, assetName) => {
  handleVirtualPatch(vulnerabilityId, componentId, assetName);
};

// Helper function to update the virtually patched list
const updateVirtuallyPatchedList = (vulnerabilityId, isPatching) => {
  if (isPatching) {
    setVirtuallyPatchedVulnerabilities([...virtuallyPatchedVulnerabilities, vulnerabilityId]);
  } else {
    setVirtuallyPatchedVulnerabilities(
      virtuallyPatchedVulnerabilities.filter(id => id !== vulnerabilityId)
    );
  }
};

// Helper function to update risk metrics based on API response
const updateRiskMetrics = (result, vulnerabilityId) => {
  // Update system risk
  setSystemRisk(result.patched_risk);

  // Update component risks for asset level or asset risks for system level
  if (analysisLevel === 'asset' && result.patched_component_risks) {
    const updatedComponentRisks = componentRisks.map((comp, idx) => ({
      ...comp,
      risk: result.patched_component_risks[idx] || comp.risk,
      originalRisk: comp.originalRisk || comp.risk
    }));

    setComponentRisks(updatedComponentRisks);
  } else if (analysisLevel === 'system' && result.asset_risks) {
    // For system level, update asset risks
    const updatedAssetRisks = result.asset_risks.map(assetRisk => {
      const originalAsset = assetRisks.find(a => a.name === assetRisk.name) || assetRisk;

      return {
        id: assetRisk.name,
        name: assetRisk.name,
        risk: assetRisk.patched_risk,
        originalRisk: originalAsset.originalRisk || originalAsset.risk,
        criticality: assetRisk.criticality
      };
    });

    setAssetRisks(updatedAssetRisks);
  }

  // Calculate impact for display
  const riskReduction = originalSystemRisk - result.patched_risk;


  const riskPercentage = ((riskReduction / originalSystemRisk) * 100).toFixed(1);

  setPatchImpact({
    ...patchImpact,
    [vulnerabilityId]: {
      systemRiskReduction: riskReduction,
      systemRiskPercentage: riskPercentage
    }
  });
};

useEffect(() => {
  // Clear error messages when changing tabs
  setError('');
  setSuccess('');
}, [selectedTab]);

useEffect(() => {
  // Reset the selected file when changing analysis level
  setSelectedFile('');
  setError(''); // Clear any previous errors
  setSuccess(''); // Also clear success messages

  // Optionally select the first available file for the new level
  setTimeout(() => {
    if (analysisLevel === 'asset' && availableConfigs.asset && availableConfigs.asset.length > 0) {
      setSelectedFile(availableConfigs.asset[0]);
    } else if (analysisLevel === 'system' && availableConfigs.system && availableConfigs.system.length > 0) {
      setSelectedFile(availableConfigs.system[0]);
    }
  }, 100);
}, [analysisLevel, availableConfigs]);

  useEffect(() => {
  // Clear component risks when changing files or analysis level
  setComponentRisks([]);
}, [analysisLevel, selectedFile]);

  useEffect(() => {
    if (analysisResults) {
      setOriginalSystemRisk(systemRisk);
      setOriginalComponentRisks([...componentRisks]);
      setOriginalAssetRisks([...assetRisks]);
    }
  }, [analysisResults]);

  // Fetch available configuration files when component mounts
  useEffect(() => {
    const fetchConfigs = async () => {
      try {
        const response = await axios.get(`${apiUrl}/configs`);
        setAvailableConfigs(response.data);
        
        // If available, set a default selected file
        if (response.data.asset.length > 0 && analysisLevel === 'asset') {
          setSelectedFile(response.data.asset[0]);
        } else if (response.data.system.length > 0 && analysisLevel === 'system') {
          setSelectedFile(response.data.system[0]);
        }
      } catch (error) {
        console.error('Error fetching configs:', error);
      }
    };

    fetchConfigs();
  }, [apiUrl, analysisLevel]);

  // Poll for results when jobId is set
  useEffect(() => {
    let interval;
    
    if (jobId && polling) {
      // Start with initial loading steps
      setLoadingSteps([
        { text: "Initializing analysis...", completed: true, timestamp: new Date().toLocaleTimeString() },
        { text: "Loading configuration...", completed: false, timestamp: null },
      ]);
      setLoadingProgress(10);

      let pollCount = 0;

      interval = setInterval(async () => {
        try {
          pollCount++;
          const response = await axios.get(`${apiUrl}/results/${jobId}`);

          // Update loading steps based on poll count
          if (pollCount === 1) {
            setLoadingSteps(prev => [
              ...prev.map((step, i) => i < 2 ? {...step, completed: true, timestamp: step.timestamp || new Date().toLocaleTimeString()} : step),
              { text: "Processing vulnerabilities...", completed: false, timestamp: null }
            ]);
            setLoadingProgress(30);
          } else if (pollCount === 2) {
            setLoadingSteps(prev => [
              ...prev.map((step, i) => i < 3 ? {...step, completed: true, timestamp: step.timestamp || new Date().toLocaleTimeString()} : step),
              { text: "Calculating risk scores...", completed: false, timestamp: null }
            ]);
            setLoadingProgress(50);
          } else if (pollCount === 3) {
            setLoadingSteps(prev => [
              ...prev.map((step, i) => i < 4 ? {...step, completed: true, timestamp: step.timestamp || new Date().toLocaleTimeString()} : step),
              { text: "Ranking vulnerabilities...", completed: false, timestamp: null }
            ]);
            setLoadingProgress(70);
          } else if (pollCount > 3) {
            setLoadingProgress(90);
          }

          if (response.data.status === 'completed') {
            clearInterval(interval);
            setPolling(false);
            setRunningAnalysis(false);

            // Update loading steps
            setLoadingSteps(prev => [
              ...prev.map(step => ({...step, completed: true, timestamp: step.timestamp || new Date().toLocaleTimeString()})),
              { text: "Analysis completed!", completed: true, timestamp: new Date().toLocaleTimeString() }
            ]);
            setLoadingProgress(100);

            // Process the results
            const results = response.data.results;
            setAnalysisResults(results);
            setPatchRankings(results.patch_rankings || []);
            setSystemRisk(results.total_risk || 0);

            // Only set component risks if it's an asset-level analysis
            if (results.level === 'asset') {
              setComponentRisks(results.component_risks || []);
            } else {
              setComponentRisks([]); // Clear component risks for system-level
            }

            // Only set asset risks if it's a system-level analysis
            if (results.level === 'system') {
              setAssetRisks(results.asset_risks || []);
            } else {
              setAssetRisks([]); // Clear asset risks for asset-level
            }

            setSelectedTab('results');

            // Add summary statistics
            setSuccess(`Analysis completed - Found ${results.patch_rankings?.length || 0} vulnerabilities`);
          } else if (response.data.status === 'error') {
            clearInterval(interval);
            setPolling(false);
            setRunningAnalysis(false);
            setError(`Analysis failed: ${response.data.results?.error || 'Unknown error'}`);

            // Update loading steps to show error
            setLoadingSteps(prev => [
              ...prev,
              { text: "Error encountered during analysis", completed: true, error: true, timestamp: new Date().toLocaleTimeString() }
            ]);
          }
        } catch (error) {
          console.error('Error polling for results:', error);
          // Don't stop polling on network errors, just wait for next try
        }
      }, 2000);
    }
    
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [jobId, polling, apiUrl]);

const runAnalysis = async () => {
  setError('');

  // Validate file selection
  if (!selectedFile) {
    setError('Please select a configuration file');
    return;
  }

  // Validate file compatibility with analysis level
  const validFiles = analysisLevel === 'asset'
    ? availableConfigs.asset
    : availableConfigs.system;

  if (!validFiles.includes(selectedFile) && !selectedFile.includes('paper_')) {
    setError(`Selected file "${selectedFile}" is not compatible with ${analysisLevel} level analysis`);
    return;
  }

  setRunningAnalysis(true);

  try {
    console.log("Starting analysis request to:", `${apiUrl}/analyze`);
    const response = await axios.post(`${apiUrl}/analyze`, {
      level: analysisLevel,
      file: selectedFile
    }, {
      timeout: 10000 // 10-second timeout
    });

    console.log("Analysis response:", response.data);

    if (response.data.job_id) {
      setJobId(response.data.job_id);
      setPolling(true);
    } else {
      setRunningAnalysis(false);
      setError('Failed to start analysis: No job ID returned');
    }
  } catch (error) {
    console.error('Error running analysis:', error);

    setRunningAnalysis(false);
    setError(`Failed to start analysis: ${error.response?.data?.error || error.message}`);
  }
};


// Handle file upload
const handleFileUpload = (event) => {
  const file = event.target.files[0];
  if (!file) return;

  // For now, just set the selected file name
  setSelectedFile(file.name);

  // Determine if it's likely a system or asset file based on name
  if (file.name.includes('ICS')) {
    setAnalysisLevel('system');
  } else {
    setAnalysisLevel('asset');
  }
};

// Color scale for risk levels
const getRiskColor = (risk) => {
  if (risk >= 40) return "#ef4444";  // High risk - red
  if (risk >= 20) return "#f97316";  // Medium risk - orange
  return "#22c55e";  // Low risk - green
};

// Reset the analysis
const resetAnalysis = () => {
  setAnalysisResults(null);
  setPatchRankings([]);
  setSystemRisk(0);
  setComponentRisks([]);
  setAssetRisks([]);
  setVirtuallyPatchedVulnerabilities([]);
  setPatchImpact({});
  setError('');
  setSuccess('');
  setSelectedTab('dashboard');
};

// Return the main UI
return (
    <div className="vulnerability-ranking-ui">
      <div className="tabs">
        <button
          className={`tab ${selectedTab === 'dashboard' ? 'active' : ''}`}
          onClick={() => setSelectedTab('dashboard')}
        >
          Dashboard
        </button>
        <button
          className={`tab ${selectedTab === 'analysis' ? 'active' : ''}`}
          onClick={() => setSelectedTab('analysis')}
        >
          Run Analysis
        </button>
        <button
          className={`tab ${selectedTab === 'results' ? 'active' : ''}`}
          onClick={() => setSelectedTab('results')}
          disabled={!analysisResults}
        >
          Results
        </button>
        <button
          className={`tab ${selectedTab === 'patches' ? 'active' : ''}`}
          onClick={() => setSelectedTab('patches')}
          disabled={!analysisResults}
        >
          Patch Rankings
        </button>
      </div>

      {selectedTab === 'dashboard' && (
        <div className="dashboard">
          <h2>Vulnerability Analysis Dashboard</h2>

          <div className="card-grid">
            <div className="card">
              <h3>Asset Level Analysis</h3>
              <p>Analyzes vulnerabilities for a single asset with multiple components</p>
              <div className="config-files">
                <h4>Available Configurations:</h4>
                {availableConfigs.asset.length > 0 ? (
                  <ul>
                    {availableConfigs.asset.map(file => (
                      <li key={file}>
                        <button
                          onClick={() => {
                            setAnalysisLevel('asset');
                            setSelectedFile(file);
                            setSelectedTab('analysis');
                          }}
                        >
                          {file}
                        </button>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="no-configs">No asset configuration files found.</p>
                )}

              </div>
            </div>

            <div className="card">
              <h3>System Level Analysis</h3>
              <p>Analyzes vulnerabilities across multiple connected assets</p>
              <div className="config-files">
                <h4>Available Configurations:</h4>
                {availableConfigs.system.length > 0 ? (
                  <ul>
                    {availableConfigs.system.map(file => (
                      <li key={file}>
                        <button
                          onClick={() => {
                            setAnalysisLevel('system');
                            setSelectedFile(file);
                            setSelectedTab('analysis');
                          }}
                        >
                          {file}
                        </button>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="no-configs">No system configuration files found.</p>
                )}

              </div>
            </div>
          </div>

          {analysisResults && (
            <div className="recent-analysis card">
              <h3>Recent Analysis</h3>
              <p><strong>Analysis Level:</strong> {analysisResults.level === 'asset' ? 'Asset' : 'System'}</p>
              <p><strong>Configuration:</strong> {analysisResults.config_file}</p>
              <p><strong>Total Risk:</strong> {analysisResults.total_risk.toFixed(2)}</p>
              <p><strong>Vulnerabilities Found:</strong> {patchRankings.length}</p>
              <button onClick={() => setSelectedTab('results')}>View Results</button>
            </div>
          )}
        </div>
      )}

      {selectedTab === 'analysis' && (
        <div className="analysis">
          <h2>Run Vulnerability Analysis</h2>

          <div className="card">
            <div className="form-group">
              <label>Analysis Level:</label>
              <select
                value={analysisLevel}
                onChange={(e) => setAnalysisLevel(e.target.value)}
                disabled={runningAnalysis}
              >
                <option value="asset">Asset Level</option>
                <option value="system">System Level</option>
              </select>
              <p className="helper-text">
                {analysisLevel === 'asset'
                  ? 'Analyze vulnerabilities within a single asset with multiple components'
                  : 'Analyze vulnerabilities across multiple connected assets'
                }
              </p>
            </div>

            <div className="form-group">
              <label>Configuration File:</label>
              <select
                  value={selectedFile}
                  onChange={(e) => setSelectedFile(e.target.value)}
                  disabled={runningAnalysis}
              >
                <option value="">Select a file</option>
                {analysisLevel === 'asset'
                    ? availableConfigs.asset.map(file => (
                        <option key={file} value={file}>{file}</option>
                    ))
                    : availableConfigs.system.map(file => (
                        <option key={file} value={file}>{file}</option>
                    ))
                }
              </select>
            </div>

            {/* File Upload Control */}
            <div className="form-group">
              <label>Upload Custom Configuration:</label>
              <input
                  type="file"
                  className="file-input"
                  accept=".json"
                  disabled={runningAnalysis}
                  onChange={handleFileUpload}
              />
              <p className="helper-text">
                Select a JSON file to upload
              </p>
            </div>

            {/* Loading Progress Bar */}
            {runningAnalysis && (
              <div className="loading-container">
                <div className="progress-bar-container">
                  <div className="progress-bar" style={{ width: `${loadingProgress}%` }}></div>
                </div>
                <div className="loading-steps">
                  {loadingSteps.map((step, index) => (
                    <div key={index} className={`loading-step ${step.completed ? 'completed' : ''} ${step.error ? 'error' : ''}`}>
                      <div className="step-status">
                        {step.completed && !step.error && <span className="status-icon">✓</span>}
                        {step.completed && step.error && <span className="status-icon error">✗</span>}
                        {!step.completed && <span className="status-icon pending">⟳</span>}
                      </div>
                      <div className="step-info">
                        <span className="step-text">{step.text}</span>
                        {step.timestamp && <span className="step-time">{step.timestamp}</span>}
                      </div>
                    </div>
                  ))}
                </div>
                <div className="analysis-stats">
                  <p>Analyzing {analysisLevel === 'asset' ? 'components and vulnerabilities' : 'assets, components, and vulnerabilities'}</p>
                  <p>Configuration: {selectedFile}</p>
                </div>
              </div>
            )}

            <div className="button-group">
              <button
                className="run-button"
                onClick={runAnalysis}
                disabled={!selectedFile || runningAnalysis}
              >
                {runningAnalysis ? 'Running Analysis...' : 'Run Analysis'}
              </button>

            </div>

            {error && <div className="error-message">{error}</div>}
            {success && <div className="success-message">{success}</div>}

            <div className="command-preview">
              <h4>Command Preview:</h4>
              <pre>python src/main.py --level {analysisLevel} --data {selectedFile}</pre>
            </div>
          </div>
        </div>
      )}

      {selectedTab === 'results' && analysisResults && (
        <div className="results">
          <h2>Analysis Results</h2>

          <div className="risk-summary card">
            <h3>{analysisLevel === 'asset' ? 'Asset' : 'System'} Risk Summary</h3>
            <div className="risk-meter">
              <div className="risk-value" style={{
                color: getRiskColor(systemRisk)
              }}>
                {systemRisk.toFixed(2)}
              </div>
              <div className="risk-scale">
                <div className="risk-level">
                  <div className="risk-label">Low</div>
                  <div className="risk-indicator" style={{ backgroundColor: '#22c55e' }}></div>
                  <div className="risk-range">0-20</div>
                </div>
                <div className="risk-level">
                  <div className="risk-label">Medium</div>
                  <div className="risk-indicator" style={{ backgroundColor: '#f97316' }}></div>
                  <div className="risk-range">20-40</div>
                </div>
                <div className="risk-level">
                  <div className="risk-label">High</div>
                  <div className="risk-indicator" style={{ backgroundColor: '#ef4444' }}></div>
                  <div className="risk-range">&gt;40</div>
                </div>
              </div>
            </div>
          </div>

          {/* Vulnerability Statistics */}
<div className="vulnerability-statistics card">
  <h3>Vulnerability Statistics</h3>
  <div className="stats-summary">
    <div className="stat-item">
      <span className="stat-label">Total Vulnerabilities:</span>
      <span className="stat-value">{patchRankings.length}</span>
    </div>
    <div className="stat-item">
      <span className="stat-label">Exploitable Vulnerabilities:</span>
      <span className="stat-value">{patchRankings.filter(p => p.exploit).length}</span>
    </div>
    <div className="stat-item">
      <span className="stat-label">Critical/High CVSS:</span>
      <span className="stat-value">
        {patchRankings.filter(p => p.cvss >= 7.0).length}
      </span>
    </div>
  </div>

  <div className="chart-grid">
    {/* CVSS Distribution Chart */}
    <div className="chart-container">
      <h4>CVSS Severity Distribution</h4>
      <ResponsiveContainer width="100%" height={300}>
        <PieChart>
          <Pie
              activeIndex={activeIndex}
              activeShape={renderActiveShape}
              data={vulnerabilityStats.cvssDistribution}
              cx="50%"
              cy="50%"
              innerRadius={60}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              onMouseEnter={onPieEnter}
          >
            {vulnerabilityStats.cvssDistribution.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={entry.color}/>
            ))}
          </Pie>
          <Tooltip/>
        </PieChart>
      </ResponsiveContainer>
    </div>

    {/* Component or Asset Distribution Chart */}
    {/* Component or Asset Distribution Chart - Without Bottom Legend */}
<div className="chart-container">
  <h4>
    {analysisLevel === 'system'
      ? 'Vulnerabilities by Asset'
      : 'Vulnerabilities by Component'}
  </h4>
  {vulnerabilityStats.locationDistribution &&
   vulnerabilityStats.locationDistribution.length > 0 ? (
    <ResponsiveContainer width="100%" height={300}>
      <PieChart>
        <Pie
          data={vulnerabilityStats.locationDistribution}
          cx="50%"
          cy="50%"
          innerRadius={60}
          outerRadius={80}
          fill="#8884d8"
          dataKey="value"
          label={(entry) => {
            try {
              const total = vulnerabilityStats.locationDistribution.reduce(
                (sum, item) => sum + (item.value || 0), 0
              );
              return `${entry.name}: ${((entry.value / total) * 100).toFixed(0)}%`;
            } catch (error) {
              return entry.name;
            }
          }}
        >
          {vulnerabilityStats.locationDistribution.map((entry, index) => (
            <Cell key={`cell-${index}`} fill={entry.color || "#8884d8"} />
          ))}
        </Pie>
        <Tooltip formatter={(value) => `${value} vulnerabilities`} />
        {/* Legend has been removed */}
      </PieChart>
    </ResponsiveContainer>
  ) : (
    <div className="no-data-message">No distribution data available</div>
  )}
</div>
  </div>
</div>

          {analysisLevel === 'system' && (
              <div className="asset-table-container">
                <table className="asset-table">
                  <thead>
                  <tr>
                    <th>Asset ID</th>
                    <th>Name</th>
                    <th>Criticality</th>
                    <th>Original Risk</th>
                    <th>Current Risk</th>
                    <th>Change</th>
                  </tr>
                  </thead>
                  <tbody>
                  {/* Remove the filter that was hiding assets with 0 risk */}
                  {assetRisks.map(asset => (
                      <tr key={asset.id}>
                        <td>{asset.id}</td>
                        <td>{asset.name}</td>
                        <td>{asset.criticality}</td>
                        <td>{asset.originalRisk?.toFixed(1) || asset.risk.toFixed(1)}</td>
                        <td className="risk-score">{asset.risk.toFixed(1)}</td>
                        <td className="risk-change">
                          {asset.originalRisk ?
                              `-${((asset.originalRisk - asset.risk) / asset.originalRisk * 100).toFixed(1)}%`
                              : '0%'}
                        </td>
                      </tr>
                  ))}
                  </tbody>
                </table>
              </div>
          )}

          {componentRisks.length > 0 && analysisLevel === 'asset' && (
              <div className="component-risks card">
                <h3>Component Risks</h3>
                <div className="chart-container">
                  <ResponsiveContainer width="100%" height={300}>
                    <BarChart data={componentRisks}>
                      <CartesianGrid strokeDasharray="3 3"/>
                      <XAxis dataKey="id"/>
                      <YAxis/>
                      <Tooltip formatter={(value) => value.toFixed(2)}/>
                      <Legend/>
                      <Bar dataKey="risk" name="Risk Score">
                        {componentRisks.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={getRiskColor(entry.risk)}/>
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
              </div>

              <table>
                <thead>
                  <tr>
                    <th>Component ID</th>
                    <th>Name</th>
                    <th>Risk Score</th>
                  </tr>
                </thead>
                <tbody>
                  {componentRisks.map(component => (
                    <tr key={component.id}>
                      <td>{component.id}</td>
                      <td>{component.name || `Component ${component.id}`}</td>
                      <td
                        style={{
                          color: getRiskColor(component.risk)
                        }}
                      >
                        {component.risk.toFixed(2)}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          <div className="button-group">
            <button onClick={() => setSelectedTab('dashboard')}>Back to Dashboard</button>
            <button onClick={() => setSelectedTab('patches')}>View Patch Rankings</button>
          </div>
        </div>
      )}

      {selectedTab === 'patches' && analysisResults && (
        <div className="patches">
          <h2>Vulnerability Patch Prioritization</h2>

          <div className="virtual-patching-header">
            <div className="risk-summary-compact">
              <div className="risk-title">
                {analysisLevel === 'asset' ? 'Asset' : 'System'} Risk Score:
              </div>
              <div className="risk-value-container">
                <div
                  className={`risk-value ${virtuallyPatchedVulnerabilities.length > 0 ? 'patched' : ''}`}
                  style={{ color: getRiskColor(systemRisk) }}
                >
                  {systemRisk.toFixed(2)}
                </div>

                {virtuallyPatchedVulnerabilities.length > 0 && (
                  <div className="risk-reduction-indicator">
                    <span className="original-value">{originalSystemRisk.toFixed(2)}</span>
                    <span className="arrow">→</span>
                    <span className="reduction-percentage">
                      {((originalSystemRisk - systemRisk) / originalSystemRisk * 100).toFixed(1)}% reduction
                    </span>
                  </div>
                )}
              </div>
            </div>

            <div className="virtual-patching-controls">
              <h3>Virtual Patching</h3>
              <p>Select vulnerabilities to simulate the impact of patching them</p>
              {virtuallyPatchedVulnerabilities.length > 0 && (
                <div className="patched-count">
                  {virtuallyPatchedVulnerabilities.length} vulnerabilities virtually patched
                  <button
                    className="reset-button"
                    onClick={resetVirtualPatching}
                  >
                    Reset All
                  </button>
                </div>
              )}
            </div>
          </div>

          <div className="patches-container">
            <div className="patch-rankings-panel">
              <h3>Patch Rankings</h3>

              {/* Only show the chart for asset-level analysis */}
              {analysisLevel === 'asset' && (
                <div className="chart-container">
                  <ResponsiveContainer width="100%" height={200}>
                    <BarChart
                      data={patchRankings.map(p => ({
                        id: p.id,
                        risk_reduction: p.risk_reduction,
                        patched: virtuallyPatchedVulnerabilities.includes(
                          `${p.id}_${p.component_id}`
                        )
                      }))}
                      margin={{ top: 5, right: 30, left: 20, bottom: 50 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis
                        dataKey="id"
                        angle={-45}
                        textAnchor="end"
                        height={60}
                        interval={0}
                      />
                      <YAxis label={{ value: 'Risk Reduction', angle: -90, position: 'insideLeft' }} />
                      <Tooltip formatter={(value) => value.toFixed(2)} />
                      <Bar dataKey="risk_reduction" name="Risk Reduction">
                        {patchRankings.map((entry, index) => (
                          <Cell
                            key={`cell-${index}`}
                            fill={virtuallyPatchedVulnerabilities.includes(
                              `${entry.id}_${entry.component_id}`
                            ) ? '#22c55e' : '#3b82f6'}
                          />
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              )}

              <div className="patch-list-container">
                {patchRankings.map((patch, index) => (
                  <div
                    key={`${patch.id}_${patch.component_id}`}
                    className={`patch-item ${virtuallyPatchedVulnerabilities.includes(
                      `${patch.id}_${patch.component_id}${analysisLevel === 'system' ? `_${patch.asset_name}` : ''}`
                    ) ? 'patched' : ''}`}
                  >
                    <div className="patch-header">
                      <h4>{index + 1}. {patch.id} (Exists in
                        Component {patch.component_id}{analysisLevel === 'system' ? `, Asset ${patch.asset_name}` : ''})</h4>
                      <div className="patch-controls">
                        <button
                          className={`patch-button ${virtuallyPatchedVulnerabilities.includes(
                            `${patch.id}_${patch.component_id}${analysisLevel === 'system' ? `_${patch.asset_name}` : ''}`
                          ) ? 'unpatch' : 'patch'}`}
                          onClick={() => simulateVirtualPatch(
                            patch.id,
                            patch.component_id,
                            analysisLevel === 'system' ? patch.asset_name : undefined
                          )}
                        >
                          {virtuallyPatchedVulnerabilities.includes(
                            `${patch.id}_${patch.component_id}${analysisLevel === 'system' ? `_${patch.asset_name}` : ''}`
                          ) ? 'Unpatch' : 'Patch'}
                        </button>
                      </div>
                    </div>

                    <div className="patch-details">
                      <div className="patch-metrics">
                        <ul>
                          <li><strong>CVSS:</strong> {patch.cvss.toFixed(1)} (Likelihood: {patch.likelihood.toFixed(1)};
                            Impact: {patch.impact.toFixed(1)})
                          </li>
                          <li><strong>EPSS:</strong> {(patch.epss * 100).toFixed(3)}%</li>
                          <li><strong>Scope changed:</strong> {patch.scopeChanged ? 'True' : 'False'}</li>
                          <li><strong>Utilized Ransomware:</strong> {patch.ransomWare ? 'Yes' : 'No'}</li>
                          <li><strong>Existing exploit:</strong> {patch.exploit ? 'Yes' : 'No'}</li>
                        </ul>
                      </div>

                      <div className="patch-impact">
                        <div className="impact-metrics">
                          <div className="impact-metric">
                            <span className="label">Risk Reduction:</span>
                            <span className="value">{patch.risk_reduction.toFixed(2)}</span>
                          </div>
                          <div className="impact-metric">
                            <span className="label">Patched Risk:</span>
                            <span className="value">{patch.patched_risk.toFixed(2)}</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Existing Scores Panel */}
            <div className="scores-panel">
              <h3>{analysisLevel === 'asset' ? 'Component' : 'Asset'} Risk Scores</h3>

              {analysisLevel === 'asset' && componentRisks.length > 0 && (
                <div className="chart-container">
                  <ResponsiveContainer width="100%" height={300}>
                    <BarChart
                      data={componentRisks.map(c => ({
                        ...c,
                        originalRisk: originalComponentRisks.find(oc => oc.id === c.id)?.risk || c.risk
                      }))}
                      layout="vertical"
                      margin={{ top: 5, right: 30, left: 100, bottom: 5 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis type="number" />
                      <YAxis
                        type="category"
                        dataKey="name"
                        width={80}
                        tick={{ fontSize: 12 }}
                      />
                      <Tooltip formatter={(value) => value.toFixed(2)} />
                      <Legend />
                      <Bar dataKey="originalRisk" name="Original Risk" fill="#9ca3af" barSize={10} />
                      <Bar dataKey="risk" name="Current Risk" fill="#3b82f6" barSize={20} />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
              )}

              {analysisLevel === 'system' && (
                <div className="asset-table-container">
                  <table className="asset-table">
                    <thead>
                      <tr>
                        <th>Asset ID</th>
                        <th>Name</th>
                        <th>Criticality</th>
                        <th>Original Risk</th>
                        <th>Current Risk</th>
                        <th>Change</th>
                      </tr>
                    </thead>
                    <tbody>
                      {assetRisks.map(asset => (
                        <tr key={asset.id}>
                          <td>{asset.id}</td>
                          <td>{asset.name}</td>
                          <td>{asset.criticality}</td>
                          <td>{asset.originalRisk?.toFixed(1) || asset.risk.toFixed(1)}</td>
                          <td className="risk-score">{asset.risk.toFixed(1)}</td>
                          <td className="risk-change">
                            {asset.originalRisk ?
                              `-${((asset.originalRisk - asset.risk) / asset.originalRisk * 100).toFixed(1)}%`
                              : '0%'}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>

          <div className="additional-considerations">
            <h3>Additional Considerations</h3>
            <ul>
              <li><strong>Existing Exploits:</strong> Vulnerabilities with existing exploits should be prioritized regardless of their ranking</li>
              <li><strong>EPSS Score:</strong> Vulnerabilities with high EPSS scores indicate a higher probability of exploitation in the wild</li>
              <li><strong>Ransomware:</strong> Vulnerabilities that enable ransomware attacks should receive urgent attention</li>
              <li><strong>Scope Change:</strong> Vulnerabilities that cause scope change can lead to privilege escalation</li>
            </ul>
          </div>

          <div className="button-group">
            <button onClick={() => setSelectedTab('results')}>Back to Results</button>
            <button onClick={resetAnalysis}>New Analysis</button>
          </div>
        </div>
      )}
    </div>
  );
};

export default VulnerabilityRankingUI;